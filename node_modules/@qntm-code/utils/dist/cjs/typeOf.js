"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.typeOf = exports.ValueType = void 0;
const isArguments_1 = require("./isArguments");
const isBuffer_1 = require("./isBuffer");
const isDate_1 = require("./isDate");
const isError_1 = require("./isError");
const isGeneratorObject_1 = require("./isGeneratorObject");
const isRegExp_1 = require("./isRegExp");
var ValueType;
(function (ValueType) {
    ValueType["undefined"] = "undefined";
    ValueType["null"] = "null";
    ValueType["boolean"] = "boolean";
    ValueType["string"] = "string";
    ValueType["number"] = "number";
    ValueType["symbol"] = "symbol";
    ValueType["function"] = "function";
    ValueType["array"] = "array";
    ValueType["buffer"] = "buffer";
    ValueType["arguments"] = "arguments";
    ValueType["date"] = "date";
    ValueType["error"] = "error";
    ValueType["regexp"] = "regexp";
    ValueType["promise"] = "promise";
    ValueType["weakmap"] = "weakmap";
    ValueType["weakset"] = "weakset";
    ValueType["map"] = "map";
    ValueType["set"] = "set";
    ValueType["int8array"] = "int8array";
    ValueType["uint8array"] = "uint8array";
    ValueType["uint8clampedarray"] = "uint8clampedarray";
    ValueType["int16array"] = "int16array";
    ValueType["uint16array"] = "uint16array";
    ValueType["int32array"] = "int32array";
    ValueType["uint32array"] = "uint32array";
    ValueType["float32array"] = "float32array";
    ValueType["float64array"] = "float64array";
    ValueType["bigint64array"] = "bigint64array";
    ValueType["biguint64array"] = "biguint64array";
    ValueType["generator"] = "generator";
    ValueType["object"] = "object";
    ValueType["mapiterator"] = "mapiterator";
    ValueType["setiterator"] = "setiterator";
    ValueType["stringiterator"] = "stringiterator";
    ValueType["arrayiterator"] = "arrayiterator";
    ValueType["generatorfunction"] = "generatorfunction";
})(ValueType = exports.ValueType || (exports.ValueType = {}));
/**
 * Determines the type of the given value
 */
function typeOf(value) {
    if (value === void 0) {
        return ValueType.undefined;
    }
    if (value === null) {
        return ValueType.null;
    }
    let type = typeof value;
    if (type === 'boolean') {
        return ValueType.boolean;
    }
    if (type === 'string') {
        return ValueType.string;
    }
    if (type === 'number') {
        return ValueType.number;
    }
    if (type === 'symbol') {
        return ValueType.symbol;
    }
    if (type === 'function') {
        return isGeneratorFunction(value) ? ValueType.generatorfunction : ValueType.function;
    }
    if (Array.isArray(value)) {
        return ValueType.array;
    }
    if ((0, isBuffer_1.isBuffer)(value)) {
        return ValueType.buffer;
    }
    if ((0, isArguments_1.isArguments)(value)) {
        return ValueType.arguments;
    }
    if ((0, isDate_1.isDate)(value)) {
        return ValueType.date;
    }
    if ((0, isError_1.isError)(value)) {
        return ValueType.error;
    }
    if ((0, isRegExp_1.isRegExp)(value)) {
        return ValueType.regexp;
    }
    switch (constructorName(value)) {
        case 'Symbol': {
            return ValueType.symbol;
        }
        case 'Promise': {
            return ValueType.promise;
        }
        case 'WeakMap': {
            return ValueType.weakmap;
        }
        case 'WeakSet': {
            return ValueType.weakset;
        }
        case 'Map': {
            return ValueType.map;
        }
        case 'Set': {
            return ValueType.set;
        }
        case 'Int8Array': {
            return ValueType.int8array;
        }
        case 'Uint8Array': {
            return ValueType.uint8array;
        }
        case 'Uint8ClampedArray': {
            return ValueType.uint8clampedarray;
        }
        case 'Int16Array': {
            return ValueType.int16array;
        }
        case 'Uint16Array': {
            return ValueType.uint16array;
        }
        case 'Int32Array': {
            return ValueType.int32array;
        }
        case 'Uint32Array': {
            return ValueType.uint32array;
        }
        case 'Float32Array': {
            return ValueType.float32array;
        }
        case 'Float64Array': {
            return ValueType.float64array;
        }
        case 'BigInt64Array': {
            return ValueType.bigint64array;
        }
        case 'BigUint64Array': {
            return ValueType.biguint64array;
        }
    }
    if ((0, isGeneratorObject_1.isGeneratorObject)(value)) {
        return ValueType.generator;
    }
    type = toString.call(value);
    switch (type) {
        case '[object Object]': {
            return ValueType.object;
        }
        case '[object Map Iterator]': {
            return ValueType.mapiterator;
        }
        case '[object Set Iterator]': {
            return ValueType.setiterator;
        }
        case '[object String Iterator]': {
            return ValueType.stringiterator;
        }
        case '[object Array Iterator]': {
            return ValueType.arrayiterator;
        }
    }
    return type.slice(8, -1).toLowerCase().replace(/\s/g, '');
}
exports.typeOf = typeOf;
function constructorName(value) {
    // eslint-disable-next-line @typescript-eslint/no-unsafe-return, @typescript-eslint/no-unsafe-member-access
    return typeof value.constructor === 'function' ? value.constructor.name : null;
}
function isGeneratorFunction(value) {
    return constructorName(value) === 'GeneratorFunction';
}
